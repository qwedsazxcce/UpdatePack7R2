name: Windows_7_ULT&ENT_32&64
on: [workflow_dispatch]

env:
  # 下载地址
  install_Windows7x86ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  install_Windows7x86ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  install_Windows7x86ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  install_Windows7x86ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  install_Windows7x86ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  install_Windows7x86ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  install_Windows7x64ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  install_Windows7x64ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  install_Windows7x64ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  install_Windows7x64ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  install_Windows7x64ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  install_Windows7x64ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003
  # 全局配置
  MAIN_ESD_NAME: Windows_7_ULT&ENT_32&64.esd
  SPLIT_VOLUME_SIZE: 1950M
  VERSION_CONFIG: |
    [
      {"Name":"Windows7x86ULTIMATE","ESDIndex":5,"Parts":3},
      {"Name":"Windows7x86ENTERPRISE","ESDIndex":1,"Parts":3},
      {"Name":"Windows7x64ULTIMATE","ESDIndex":4,"Parts":3},
      {"Name":"Windows7x64ENTERPRISE","ESDIndex":1,"Parts":3}
    ]

jobs:
  process_and_upload:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      # 关键：强制设置CMD编码为GBK，解决DISM中文乱码
      - name: Set system encoding to GBK
        run: |
          # 永久设置当前会话编码为GBK（针对DISM）
          chcp 936 | Out-Null
          Write-Host "System encoding set to GBK (936) for DISM Chinese support"

      - name: Install dependencies
        run: |
          # 安装GitHub CLI
          if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
            winget install --id GitHub.cli --silent --accept-package-agreements --accept-source-agreements
          }
          # 校验7z
          if (-not (Get-Command 7z -ErrorAction SilentlyContinue)) {
            throw "7z.exe is required"
          }
          # 认证GH
          $env:GH_TOKEN | gh auth login --with-token
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Initialize ESD file
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          if (Test-Path $mainESD) { Remove-Item $mainESD -Force }
          New-Item -Path $mainESD -ItemType File -Force | Out-Null
          Write-Host "ESD file initialized: $mainESD"

      - name: Core workflow (download -> extract -> convert)
        run: |
          # 函数1：下载分卷（稳定重试逻辑）
          function Download-7zParts {
            param([string]$VerName, [int]$PartCount)
            $success = $true
            for ($i=1; $i -le $PartCount; $i++) {
              $partNum = "{0:D3}" -f $i
              $url = [Environment]::GetEnvironmentVariable("install_${VerName}_${partNum}")
              $savePath = "$VerName.7z.$partNum"
              
              if (-not $url) {
                Write-Error "No URL for $VerName part $i"
                $success = $false
                continue
              }

              # 3次重试下载
              $retryCount = 0
              do {
                try {
                  if (Test-Path $savePath) { Remove-Item $savePath -Force }
                  # 使用curl下载，超时300秒
                  curl.exe -L -o $savePath $url --connect-timeout 30 --max-time 300
                  
                  # 校验文件
                  if ($LASTEXITCODE -ne 0 -or (Get-Item $savePath).Length -lt 1KB) {
                    throw "Download failed (exit code: $LASTEXITCODE, size: $(Get-Item $savePath).Length)"
                  }
                  
                  Write-Host "✅ $VerName part $i downloaded: $([math]::Round((Get-Item $savePath).Length/1MB,2)) MB"
                  break
                }
                catch {
                  $retryCount++
                  Write-Warning "⚠️ Retry $retryCount/3 for $VerName part $i: $_"
                  if ($retryCount -eq 3) {
                    $success = $false
                    break
                  }
                  Start-Sleep -Seconds 5
                }
              } while ($retryCount -lt 3)

              if (-not $success) { break }
            }
            return $success
          }

          # 函数2：读取WIM信息（核心修复：无变量编码，直接用Default=GBK）
          function Get-WimIndexInfo {
            param([string]$WimPath, [int]$TargetIndex)
            # 临时文件（固定名称，避免GUID混乱）
            $tempOut = "dism_output.txt"
            $tempErr = "dism_error.txt"
            
            # 清理旧临时文件
            if (Test-Path $tempOut) { Remove-Item $tempOut -Force }
            if (Test-Path $tempErr) { Remove-Item $tempErr -Force }

            try {
              # 执行DISM：强制GBK输出，重定向到文件
              cmd /c "chcp 936 && dism.exe /Get-WimInfo /WimFile:`"$WimPath`" /Index:$TargetIndex > $tempOut 2> $tempErr"
              $exitCode = $LASTEXITCODE

              # 读取输出：使用Default编码（对应系统GBK），永不Null
              $dismOut = if (Test-Path $tempOut) { Get-Content $tempOut -Encoding Default -Raw } else { "" }
              $dismErr = if (Test-Path $tempErr) { Get-Content $tempErr -Encoding Default -Raw } else { "" }

              # 校验执行结果
              if ($exitCode -ne 0) { throw "DISM failed (code: $exitCode): $dismErr" }
              if ([string]::IsNullOrWhiteSpace($dismOut)) { throw "DISM output is empty" }

              # 解析索引、名称、描述（精准正则）
              $indexMatch = [regex]::Matches($dismOut, '(?mi)^Index\s*:\s*(\d+)')
              $validIndexes = $indexMatch.Groups | Where-Object { $_.Success -and $_.Value -match '\d+' } | ForEach-Object { [int]$_.Groups[1].Value }
              
              $name = [regex]::Match($dismOut, '(?mi)^Name\s*:\s*(.+)').Groups[1].Value.Trim()
              $desc = [regex]::Match($dismOut, '(?mi)^Description\s*:\s*(.+)').Groups[1].Value.Trim()

              # 返回结果
              return [PSCustomObject]@{
                ValidIndexes = $validIndexes
                ImageName    = if ($name) { $name } else { "Unknown Name" }
                ImageDesc    = if ($desc) { $desc } else { "Unknown Description" }
              }
            }
            catch {
              throw "Failed to read WIM info: $_`nDISM Output: $dismOut`nDISM Error: $dismErr"
            }
            finally {
              # 清理临时文件
              Remove-Item $tempOut, $tempErr -Force -ErrorAction SilentlyContinue
            }
          }

          # 主逻辑执行
          $versions = $env:VERSION_CONFIG | ConvertFrom-Json -ErrorAction Stop
          $mainESDAbs = (Resolve-Path $env:MAIN_ESD_NAME).Path

          foreach ($ver in $versions) {
            $verName = $ver.Name
            $targetIdx = $ver.ESDIndex
            $partCount = $ver.Parts

            Write-Host "`n=================================================="
            Write-Host "Processing version: $verName (Target Index: $targetIdx)"
            Write-Host "=================================================="

            # 1. 下载分卷
            Write-Host "Step 1: Downloading $verName parts ($partCount total)"
            if (-not (Download-7zParts -VerName $verName -PartCount $partCount)) {
              Write-Error "❌ Download failed for $verName, skip to next version"
              continue
            }

            # 2. 解压分卷
            Write-Host "Step 2: Extracting $verName"
            $first7z = "$verName.7z.001"
            $extractDir = "$verName"
            7z.exe x "$first7z" -o"$extractDir" -y -bb0 | Out-Null
            
            if ($LASTEXITCODE -ne 0 -or -not (Test-Path $extractDir)) {
              Write-Error "❌ Extract failed for $verName, skip"
              continue
            }

            # 3. 查找WIM文件
            Write-Host "Step 3: Finding WIM file"
            $wimFile = Get-ChildItem -Path $extractDir -Filter *.wim -Recurse -ErrorAction SilentlyContinue | Select-Object -First 1
            if (-not $wimFile) {
              Write-Error "❌ No WIM file found for $verName, skip"
              continue
            }
            $wimPath = $wimFile.FullName
            Write-Host "Found WIM: $wimPath ($([math]::Round($wimFile.Length/1GB,2)) GB)"

            # 4. 读取WIM信息（核心修复）
            Write-Host "Step 4: Reading WIM info for index $targetIdx"
            try {
              $wimInfo = Get-WimIndexInfo -WimPath $wimPath -TargetIndex $targetIdx
              
              # 校验目标索引是否存在
              if (-not $wimInfo.ValidIndexes.Contains($targetIdx)) {
                throw "Target index $targetIdx not in valid indexes: $($wimInfo.ValidIndexes -join ', ')"
              }
              
              Write-Host "✅ WIM Index $targetIdx info:"
              Write-Host "   Name: $($wimInfo.ImageName)"
              Write-Host "   Description: $($wimInfo.ImageDesc)"
            }
            catch {
              Write-Error "❌ Failed to read WIM info: $_"
              continue
            }

            # 5. 转换WIM to ESD（追加模式）
            Write-Host "Step 5: Converting WIM index $targetIdx to ESD"
            dism.exe /Export-Image `
              /SourceImageFile:"$wimPath" `
              /SourceIndex:$targetIdx `
              /DestinationImageFile:"$mainESDAbs" `
              /Compress:recovery `
              /CheckIntegrity `
              /Append | Out-Null
            
            if ($LASTEXITCODE -eq 0) {
              $esdSize = [math]::Round((Get-Item $mainESDAbs).Length/1GB,2)
              Write-Host "✅ ESD conversion success! Current ESD size: $esdSize GB"
            }
            else {
              Write-Error "❌ ESD conversion failed (exit code: $LASTEXITCODE)"
            }

            # 6. 清理临时文件
            Write-Host "Step 6: Cleaning up $verName temp files"
            Remove-Item -Path $extractDir -Recurse -Force -ErrorAction SilentlyContinue
            Remove-Item -Path "$verName.7z.*" -Force -ErrorAction SilentlyContinue
            Write-Host "✅ $verName processing completed"
          }

      - name: Split ESD to 7z parts
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          $splitSize = $env:SPLIT_VOLUME_SIZE
          $7zPrefix = "$mainESD.7z"

          if (-not (Test-Path $mainESD)) {
            throw "ESD file $mainESD not found"
          }

          Write-Host "Splitting ESD to 7z parts (size: $splitSize)"
          7z.exe a "$7zPrefix" "$mainESD" -v$splitSize -y -mx=9 -bb0 | Out-Null

          if ($LASTEXITCODE -eq 0) {
            $splitFiles = Get-ChildItem -Path "$7zPrefix.*"
            Write-Host "✅ Split success! Generated $($splitFiles.Count) files:"
            $splitFiles | Select-Object Name, @{Name="Size(MB)"; Expression={[math]::Round($_.Length/1MB,2)}} | Format-Table -AutoSize
            Remove-Item $mainESD -Force
          }
          else {
            throw "7z split failed (exit code: $LASTEXITCODE)"
          }

      - name: Publish to GitHub Release
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          $splitFiles = Get-ChildItem -Path "$7zPrefix.*"

          if (-not $splitFiles) {
            throw "No split files to upload"
          }

          # 删除旧Release
          gh release delete $releaseTag -y 2>&1 | Out-Null
          git tag -d $releaseTag 2>&1 | Out-Null
          git push origin --delete $releaseTag 2>&1 | Out-Null

          # 创建新Release
          gh release create $releaseTag `
            --title "$releaseTag" `
            --notes "Windows7 ULT&ENT 32&64 ESD | Split size: $($env:SPLIT_VOLUME_SIZE) | Build time: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

          # 上传文件
          foreach ($file in $splitFiles) {
            Write-Host "Uploading $($file.Name)..."
            gh release upload $releaseTag "$($file.FullName)" --clobber
          }
          Write-Host "✅ All files uploaded to Release: $releaseTag"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Final cleanup
        run: |
          Write-Host "Final cleanup of temp files"
          Get-ChildItem -Path @("*.7z.*", "*.wim", $env:MAIN_ESD_NAME, "dism_*.txt") -ErrorAction SilentlyContinue | Remove-Item -Force
          Get-ChildItem -Path * -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match "Windows7" } | Remove-Item -Recurse -Force
          Write-Host "✅ Cleanup completed"
