name: Windows_7_ULT&ENT_32&64

env:
  # Download URL environment variables - for easy replacement later
  WIN7_X86_ULTIMATE_URL_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  WIN7_X86_ULTIMATE_URL_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  WIN7_X86_ULTIMATE_URL_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  WIN7_X86_ENTERPRISE_URL_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  WIN7_X86_ENTERPRISE_URL_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  WIN7_X86_ENTERPRISE_URL_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  WIN7_X64_ULTIMATE_URL_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  WIN7_X64_ULTIMATE_URL_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  WIN7_X64_ULTIMATE_URL_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  WIN7_X64_ENTERPRISE_URL_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  WIN7_X64_ENTERPRISE_URL_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  WIN7_X64_ENTERPRISE_URL_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003

"on":
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/Windows_7_ULT_ENT_32_64.yml'

jobs:
  build:
    runs-on: windows-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: Setup 7-Zip
      run: |
        choco install 7zip -y
        echo "C:\Program Files\7-Zip" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
        
    - name: Create working directory
      run: |
        mkdir workdir
        cd workdir
        
    # Process Windows 7 x86 Ultimate (第5个映象)
    - name: Download Windows 7 x86 Ultimate part 1
      run: |
        cd workdir
        curl -L -o install_Windows7x86ULTIMATE.7z.001 ${{ env.WIN7_X86_ULTIMATE_URL_001 }}
        
    - name: Download Windows 7 x86 Ultimate part 2
      run: |
        cd workdir
        curl -L -o install_Windows7x86ULTIMATE.7z.002 ${{ env.WIN7_X86_ULTIMATE_URL_002 }}
        
    - name: Download Windows 7 x86 Ultimate part 3
      run: |
        cd workdir
        curl -L -o install_Windows7x86ULTIMATE.7z.003 ${{ env.WIN7_X86_ULTIMATE_URL_003 }}
        
    - name: Extract Windows 7 x86 Ultimate archive
      run: |
        cd workdir
        7z x install_Windows7x86ULTIMATE.7z.001 -owin7_x86_ultimate
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to extract Windows 7 x86 Ultimate archive"
        }
        
    - name: Find and process WIM file for x86 Ultimate
      run: |
        cd workdir\win7_x86_ultimate
        $wimFile = Get-ChildItem -Path . -Filter "*.wim" -Recurse | Select-Object -First 1
        if ($wimFile -and (Test-Path $wimFile.FullName)) {
            Write-Host "Found WIM file: $($wimFile.Name)"
            
            # Export fifth image to new WIM file (第5个映象)
            $destWim = "..\..\Windows7_ULT&ENT_32&64.wim"
            dism /Export-Image /SourceImageFile:"$($wimFile.FullName)" /SourceIndex:5 /DestinationImageFile:$destWim /DestinationName:"Windows 7 x86 Ultimate" /Compress:max
            if ($LASTEXITCODE -ne 0) {
                throw "Failed to export WIM image for x86 Ultimate"
            }
            Write-Host "Successfully created initial WIM file with x86 Ultimate"
        } else {
            throw "No WIM file found in x86 Ultimate archive"
        }
        
    - name: Cleanup Windows 7 x86 Ultimate temporary files
      run: |
        cd workdir
        Remove-Item install_Windows7x86ULTIMATE.7z.001 -Force
        Remove-Item install_Windows7x86ULTIMATE.7z.002 -Force
        Remove-Item install_Windows7x86ULTIMATE.7z.003 -Force
        Remove-Item win7_x86_ultimate -Recurse -Force
        
    # Process Windows 7 x86 Enterprise (第1个映象)
    - name: Download Windows 7 x86 Enterprise part 1
      run: |
        cd workdir
        curl -L -o install_Windows7x86ENTERPRISE.7z.001 ${{ env.WIN7_X86_ENTERPRISE_URL_001 }}
        
    - name: Download Windows 7 x86 Enterprise part 2
      run: |
        cd workdir
        curl -L -o install_Windows7x86ENTERPRISE.7z.002 ${{ env.WIN7_X86_ENTERPRISE_URL_002 }}
    
    - name: Download Windows 7 x86 Enterprise part 3
      run: |
        cd workdir
        curl -L -o install_Windows7x86ENTERPRISE.7z.003 ${{ env.WIN7_X86_ENTERPRISE_URL_003 }}
        
    - name: Extract Windows 7 x86 Enterprise archive
      run: |
        cd workdir
        7z x install_Windows7x86ENTERPRISE.7z.001 -owin7_x86_enterprise
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to extract Windows 7 x86 Enterprise archive"
        }
        
    - name: Find and append WIM file for x86 Enterprise
      run: |
        cd workdir\win7_x86_enterprise
        $wimFile = Get-ChildItem -Path . -Filter "*.wim" -Recurse | Select-Object -First 1
        if ($wimFile -and (Test-Path $wimFile.FullName)) {
            Write-Host "Found WIM file: $($wimFile.Name)"
            
            # Export first image and append to existing WIM file (第1个映象)
            $destWim = "..\..\Windows7_ULT&ENT_32&64.wim"
            dism /Export-Image /SourceImageFile:"$($wimFile.FullName)" /SourceIndex:1 /DestinationImageFile:$destWim /DestinationName:"Windows 7 x86 Enterprise" /Compress:max
            if ($LASTEXITCODE -ne 0) {
                throw "Failed to append WIM image for x86 Enterprise"
            }
            Write-Host "Successfully appended x86 Enterprise image"
        } else {
            throw "No WIM file found in x86 Enterprise archive"
        }
        
    - name: Cleanup Windows 7 x86 Enterprise temporary files
      run: |
        cd workdir
        Remove-Item install_Windows7x86ENTERPRISE.7z.001 -Force
        Remove-Item install_Windows7x86ENTERPRISE.7z.002 -Force
        Remove-Item install_Windows7x86ENTERPRISE.7z.003 -Force
        Remove-Item win7_x86_enterprise -Recurse -Force
        
    # Process Windows 7 x64 Ultimate (第4个映象)
    - name: Download Windows 7 x64 Ultimate part 1
      run: |
        cd workdir
        curl -L -o install_Windows7x64ULTIMATE.7z.001 ${{ env.WIN7_X64_ULTIMATE_URL_001 }}
        
    - name: Download Windows 7 x64 Ultimate part 2
      run: |
        cd workdir
        curl -L -o install_Windows7x64ULTIMATE.7z.002 ${{ env.WIN7_X64_ULTIMATE_URL_002 }}
        
    - name: Download Windows 7 x64 Ultimate part 3
      run: |
        cd workdir
        curl -L -o install_Windows7x64ULTIMATE.7z.003 ${{ env.WIN7_X64_ULTIMATE_URL_003 }}
        
    - name: Extract Windows 7 x64 Ultimate archive
      run: |
        cd workdir
        7z x install_Windows7x64ULTIMATE.7z.001 -owin7_x64_ultimate
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to extract Windows 7 x64 Ultimate archive"
        }
        
    - name: Find and append WIM file for x64 Ultimate
      run: |
        cd workdir\win7_x64_ultimate
        $wimFile = Get-ChildItem -Path . -Filter "*.wim" -Recurse | Select-Object -First 1
        if ($wimFile -and (Test-Path $wimFile.FullName)) {
            Write-Host "Found WIM file: $($wimFile.Name)"
            
            # Export fourth image and append to existing WIM file (第4个映象)
            $destWim = "..\..\Windows7_ULT&ENT_32&64.wim"
            dism /Export-Image /SourceImageFile:"$($wimFile.FullName)" /SourceIndex:4 /DestinationImageFile:$destWim /DestinationName:"Windows 7 x64 Ultimate" /Compress:max
            if ($LASTEXITCODE -ne 0) {
                throw "Failed to append WIM image for x64 Ultimate"
            }
            Write-Host "Successfully appended x64 Ultimate image"
        } else {
            throw "No WIM file found in x64 Ultimate archive"
        }
        
    - name: Cleanup Windows 7 x64 Ultimate temporary files
      run: |
        cd workdir
        Remove-Item install_Windows7x64ULTIMATE.7z.001 -Force
        Remove-Item install_Windows7x64ULTIMATE.7z.002 -Force
        Remove-Item install_Windows7x64ULTIMATE.7z.003 -Force
        Remove-Item win7_x64_ultimate -Recurse -Force
        
    # Process Windows 7 x64 Enterprise (第1个映象)
    - name: Download Windows 7 x64 Enterprise part 1
      run: |
        cd workdir
        curl -L -o install_Windows7x64ENTERPRISE.7z.001 ${{ env.WIN7_X64_ENTERPRISE_URL_001 }}
        
    - name: Download Windows 7 x64 Enterprise part 2
      run: |
        cd workdir
        curl -L -o install_Windows7x64ENTERPRISE.7z.002 ${{ env.WIN7_X64_ENTERPRISE_URL_002 }}
        
    - name: Download Windows 7 x64 Enterprise part 3
      run: |
        cd workdir
        curl -L -o install_Windows7x64ENTERPRISE.7z.003 ${{ env.WIN7_X64_ENTERPRISE_URL_003 }}
        
    - name: Extract Windows 7 x64 Enterprise archive
      run: |
        cd workdir
        7z x install_Windows7x64ENTERPRISE.7z.001 -owin7_x64_enterprise
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to extract Windows 7 x64 Enterprise archive"
        }
        
    - name: Find and append WIM file for x64 Enterprise
      run: |
        cd workdir\win7_x64_enterprise
        $wimFile = Get-ChildItem -Path . -Filter "*.wim" -Recurse | Select-Object -First 1
        if ($wimFile -and (Test-Path $wimFile.FullName)) {
            Write-Host "Found WIM file: $($wimFile.Name)"
            
            # Export first image and append to existing WIM file (第1个映象)
            $destWim = "..\..\Windows7_ULT&ENT_32&64.wim"
            dism /Export-Image /SourceImageFile:"$($wimFile.FullName)" /SourceIndex:1 /DestinationImageFile:$destWim /DestinationName:"Windows 7 x64 Enterprise" /Compress:max
            if ($LASTEXITCODE -ne 0) {
                throw "Failed to append WIM image for x64 Enterprise"
            }
            Write-Host "Successfully appended x64 Enterprise image"
        } else {
            throw "No WIM file found in x64 Enterprise archive"
        }
        
    - name: Cleanup Windows 7 x64 Enterprise temporary files
      run: |
        cd workdir
        Remove-Item install_Windows7x64ENTERPRISE.7z.001 -Force
        Remove-Item install_Windows7x64ENTERPRISE.7z.002 -Force
        Remove-Item install_Windows7x64ENTERPRISE.7z.003 -Force
        Remove-Item win7_x64_enterprise -Recurse -Force
        
    # Convert final WIM to ESD
    - name: Convert WIM to ESD with maximum compression
      run: |
        cd workdir
        
        # Verify source WIM file exists
        $wimPath = "Windows7_ULT&ENT_32&64.wim"
        if (Test-Path $wimPath) {
            Write-Host "Found WIM file: $wimPath"
            $wimFile = Get-Item $wimPath
        } else {
            Write-Host "Looking for WIM file in parent directory..."
            $wimPath = "..\\Windows7_ULT&ENT_32&64.wim"
            if (Test-Path $wimPath) {
                Write-Host "Found WIM file: $wimPath"
                $wimFile = Get-Item $wimPath
            } else {
                # Check all subdirectories
                $wimFile = Get-ChildItem -Path .. -Filter "Windows7_ULT&ENT_32&64.wim" -Recurse | Select-Object -First 1
                if (-not $wimFile) {
                    Write-Host "WIM files in workdir: $(Get-ChildItem -Path . -Filter "*.wim" -Recurse)"
                    throw "Source WIM file not found"
                }
            }
        }
        
        Write-Host "Converting WIM to ESD with maximum compression..."
        $esdFile = "Windows7_ULT&ENT_32&64.esd"
        # Ensure full path is used for both source and destination
        $sourcePath = Resolve-Path $wimFile.FullName
        # Ensure full path is used for both source and destination
        $sourcePath = Resolve-Path $wimFile.FullName
        # Export all images from WIM to ESD in one operation
        # Since /SourceIndex:ALL is not valid, we'll export all by using a loop
        # First get the WIM information to know how many images there are
        $wimInfo = dism /Get-WimInfo /WimFile:"$sourcePath" /Format:List
        $imageCount = [regex]::Matches($wimInfo, "Index : \d+").Count
        
        if ($imageCount -gt 0) {
            # Export first image to create the ESD file
            dism /Export-Image /SourceImageFile:"$sourcePath" /SourceIndex:1 /DestinationImageFile:"$esdFile" /Compress:recovery
            
            # Export remaining images to append to the same ESD file
            for ($i = 2; $i -le $imageCount; $i++) {
                dism /Export-Image /SourceImageFile:"$sourcePath" /SourceIndex:$i /DestinationImageFile:"$esdFile" /Compress:recovery
                if ($LASTEXITCODE -ne 0) {
                    Write-Host "Warning: Failed to export image index $i, continuing..."
                }
            }
        } else {
            throw "No images found in WIM file to export"
        }
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to convert WIM to ESD"
        }
        
        # Verify ESD file was created
        if (Test-Path $esdFile) {
            Write-Host "Successfully converted to ESD format"
            $esdSize = (Get-Item $esdFile).Length
            Write-Host "ESD file size: $($esdSize / 1GB) GB"
        } else {
            throw "ESD file was not created"
        }
        
    - name: Split ESD file into 1950MB volumes
      run: |
        cd workdir
        
        # Verify ESD file exists before splitting
        $esdFile = "Windows7_ULT&ENT_32&64.esd"
        if (Test-Path $esdFile) {
            Write-Host "Found ESD file: $esdFile"
        } else {
            Write-Host "ESD file not found in current directory. Available files: $(Get-ChildItem -Path . -Filter "*.esd")"
            throw "ESD file not found for splitting"
        }
        
        Write-Host "Splitting ESD file into 1950MB volumes..."
        $outputArchive = "Windows7_ULT&ENT_32&64.7z"
        7z a -v1950M "$outputArchive" "$esdFile"
        if ($LASTEXITCODE -ne 0) {
            throw "Failed to split ESD file"
        }
        
        Write-Host "Verifying split archive integrity..."
        7z t "$outputArchive.001"
        if ($LASTEXITCODE -ne 0) {
            throw "Split archive integrity check failed"
        }
        
        # Verify split files were created
        $splitFiles = Get-ChildItem -Path . -Filter "Windows7_ULT&ENT_32&64.7z.*"
        if ($splitFiles -and $splitFiles.Count -gt 0) {
            Write-Host "Created $($splitFiles.Count) volume files:"
            foreach ($file in $splitFiles) {
                Write-Host "  $($file.Name) - $($file.Length / 1MB) MB"
            }
        } else {
            throw "No split volume files were created"
        }
        
# Delete existing release and tag if they exist
- name: Delete existing release and tag
  shell: pwsh  # 明确指定PowerShell Shell，匹配脚本语法
  run: |
    # 定义目标名称（统一管理，避免重复书写，方便后续修改）
    $targetName = "Windows7_ULT&ENT_32&64"
    
    # ===== 1. 检查并删除Release =====
    try {
        # 用双引号包裹含特殊字符的名称，重定向错误输出避免冗余报错
        $releaseId = gh release view "$targetName" --json id --jq ".id" 2>&1
        # 通过gh命令的退出码判断Release是否存在（最可靠的方式）
        if ($LASTEXITCODE -eq 0) {
            Write-Host "Found existing release: $targetName, deleting..."
            gh release delete "$targetName" --cleanup-tag --yes  # --cleanup-tag会同步删除关联Tag
        } else {
            Write-Host "No existing release found for: $targetName"
        }
    }
    catch {
        Write-Host "No existing release found for: $targetName (error: $_)"
    }

    # ===== 2. 兜底检查并删除Tag（防止--cleanup-tag未生效） =====
    try {
        # 用双引号包裹标签名，指定refs/tags完整路径
        git ls-remote --tags origin "refs/tags/$targetName" 2>&1 | Out-Null
        if ($LASTEXITCODE -eq 0) {
            Write-Host "Found existing tag: $targetName, deleting..."
            git push origin --delete "refs/tags/$targetName"
        } else {
            Write-Host "No existing tag found for: $targetName"
        }
    }
    catch {
        Write-Host "No existing tag found for: $targetName (error: $_)"
    }
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # 统一使用GITHUB_TOKEN（gh命令兼容此变量）

# Upload release assets
- name: Upload release assets
  uses: softprops/action-gh-release@v1
  with:
    name: Windows7_ULT&ENT_32&64  # Release显示名称
    tag_name: Windows7_ULT&ENT_32&64  # Tag名称（含特殊字符无需额外转义，action会处理）
    draft: false
    prerelease: false
    generate_release_notes: false
    overwrite: false  # 已提前删除旧Release，无需覆盖
    files: |
      workdir/*.7z.*  # 匹配workdir下所有.7z.开头的分片压缩文件
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
