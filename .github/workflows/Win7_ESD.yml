name: Windows_7_ULT&ENT_32&64
on: [workflow_dispatch]

env:
  # 下载地址
  install_Windows7x86ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  install_Windows7x86ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  install_Windows7x86ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  install_Windows7x86ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  install_Windows7x86ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  install_Windows7x86ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  install_Windows7x64ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  install_Windows7x64ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  install_Windows7x64ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  install_Windows7x64ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  install_Windows7x64ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  install_Windows7x64ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003
  # 全局配置
  MAIN_ESD_NAME: Windows_7_ULT&ENT_32&64.esd
  SPLIT_VOLUME_SIZE: 1950M
  VERSION_CONFIG: |
    [
      {"Name":"Windows7x86ULTIMATE","ESDIndex":5,"Parts":3},
      {"Name":"Windows7x86ENTERPRISE","ESDIndex":1,"Parts":3},
      {"Name":"Windows7x64ULTIMATE","ESDIndex":4,"Parts":3},
      {"Name":"Windows7x64ENTERPRISE","ESDIndex":1,"Parts":3}
    ]

jobs:
  process_and_upload:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set system encoding to GBK
        run: |
          chcp 936 | Out-Null
          Write-Host "System encoding set to GBK (936)"

      - name: Initialize ESD file
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          if (Test-Path $mainESD) { Remove-Item $mainESD -Force }
          New-Item -Path $mainESD -ItemType File -Force | Out-Null
          Write-Host "ESD file initialized: $mainESD"

      - name: Core workflow
        run: |
          # 函数1：下载分卷（修复语法错误）
          function Download-7zParts {
            param([string]$VerName, [int]$PartCount)
            $success = $true
            for ($i=1; $i -le $PartCount; $i++) {
              $partNum = "{0:D3}" -f $i
              $url = [Environment]::GetEnvironmentVariable("install_${VerName}_${partNum}")
              $savePath = "$VerName.7z.$partNum"
              
              if (-not $url) {
                Write-Error "URL is empty for $VerName part $i"
                $success = $false
                continue
              }

              $retry = 0
              do {
                try {
                  if (Test-Path $savePath) { Remove-Item $savePath -Force }
                  curl.exe -L -o $savePath $url --connect-timeout 30 --max-time 300
                  
                  if ($LASTEXITCODE -ne 0 -or (Get-Item $savePath).Length -lt 1KB) {
                    throw "Download failed or file size too small"
                  }
                  
                  Write-Host "$VerName part $i downloaded successfully: $([math]::Round((Get-Item $savePath).Length/1MB,2)) MB"
                  break
                }
                catch {
                  $retry++
                  # 核心修复：冒号后加空格，避免变量解析错误
                  Write-Warning "Retry $retry/3 for $VerName part $i : $_"
                  if ($retry -eq 3) {
                    $success = $false
                    break
                  }
                  Start-Sleep -Seconds 5
                }
              } while ($retry -lt 3)

              if (-not $success) { break }
            }
            return $success
          }

          # 函数2：读取WIM信息
          function Get-WimIndexInfo {
            param([string]$WimPath, [int]$TargetIndex)
            $tempOut = "dism_out.txt"
            $tempErr = "dism_err.txt"

            if (Test-Path $tempOut) { Remove-Item $tempOut -Force }
            if (Test-Path $tempErr) { Remove-Item $tempErr -Force }

            try {
              cmd /c "chcp 936 && dism.exe /Get-WimInfo /WimFile:`"$WimPath`" /Index:$TargetIndex > $tempOut 2> $tempErr"
              if ($LASTEXITCODE -ne 0) {
                $errMsg = Get-Content $tempErr -Encoding Default -Raw
                throw "DISM execution failed: $errMsg"
              }

              $dismOut = Get-Content $tempOut -Encoding Default -Raw
              if ([string]::IsNullOrWhiteSpace($dismOut)) {
                throw "DISM output is empty"
              }

              $name = [regex]::Match($dismOut, '(?mi)^Name\s*:\s*(.+)').Groups[1].Value.Trim()
              $desc = [regex]::Match($dismOut, '(?mi)^Description\s*:\s*(.+)').Groups[1].Value.Trim()
              $indexes = [regex]::Matches($dismOut, '(?mi)^Index\s*:\s*(\d+)').Groups | Where-Object { $_.Success } | ForEach-Object { [int]$_.Groups[1].Value }

              return [PSCustomObject]@{
                ValidIndexes = $indexes
                ImageName = $name
                ImageDesc = $desc
              }
            }
            catch {
              throw "Failed to read WIM info: $_"
            }
            finally {
              Remove-Item $tempOut, $tempErr -Force -ErrorAction SilentlyContinue
            }
          }

          # 主逻辑
          $versions = $env:VERSION_CONFIG | ConvertFrom-Json
          $mainESDAbs = (Resolve-Path $env:MAIN_ESD_NAME).Path

          foreach ($ver in $versions) {
            $verName = $ver.Name
            $targetIdx = $ver.ESDIndex
            $partCount = $ver.Parts

            Write-Host "`n====================================="
            Write-Host "Processing: $verName (Index: $targetIdx)"
            Write-Host "====================================="

            # 1. 下载
            Write-Host "1. Downloading $verName parts"
            if (-not (Download-7zParts -VerName $verName -PartCount $partCount)) {
              Write-Error "Download failed for $verName, skip"
              continue
            }

            # 2. 解压
            Write-Host "2. Extracting $verName"
            $first7z = "$verName.7z.001"
            $extractDir = "$verName"
            7z.exe x "$first7z" -o"$extractDir" -y -bb0 | Out-Null
            if ($LASTEXITCODE -ne 0 -or -not (Test-Path $extractDir)) {
              Write-Error "Extract failed for $verName, skip"
              continue
            }

            # 3. 找WIM
            Write-Host "3. Finding WIM file"
            $wimFile = Get-ChildItem -Path $extractDir -Filter *.wim -Recurse | Select-Object -First 1
            if (-not $wimFile) {
              Write-Error "No WIM file found for $verName, skip"
              continue
            }
            $wimPath = $wimFile.FullName
            Write-Host "Found WIM: $wimPath ($([math]::Round($wimFile.Length/1GB,2)) GB)"

            # 4. 读WIM信息
            Write-Host "4. Reading WIM info for index $targetIdx"
            try {
              $wimInfo = Get-WimIndexInfo -WimPath $wimPath -TargetIndex $targetIdx
              if (-not $wimInfo.ValidIndexes.Contains($targetIdx)) {
                throw "Index $targetIdx not found in WIM"
              }
              Write-Host "Image Name: $($wimInfo.ImageName)"
              Write-Host "Image Description: $($wimInfo.ImageDesc)"
            }
            catch {
              Write-Error "Read WIM info failed: $_"
              continue
            }

            # 5. 转ESD
            Write-Host "5. Converting WIM to ESD"
            dism.exe /Export-Image `
              /SourceImageFile:"$wimPath" `
              /SourceIndex:$targetIdx `
              /DestinationImageFile:"$mainESDAbs" `
              /Compress:recovery `
              /CheckIntegrity `
              /Append | Out-Null
            if ($LASTEXITCODE -eq 0) {
              $esdSize = [math]::Round((Get-Item $mainESDAbs).Length/1GB,2)
              Write-Host "ESD conversion success, size: $esdSize GB"
            }
            else {
              Write-Error "ESD conversion failed"
            }

            # 6. 清理
            Write-Host "6. Cleaning up temp files"
            Remove-Item $extractDir -Recurse -Force -ErrorAction SilentlyContinue
            Remove-Item "$verName.7z.*" -Force -ErrorAction SilentlyContinue
          }

      - name: Split ESD to 7z
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          $splitSize = $env:SPLIT_VOLUME_SIZE
          $7zPrefix = "$mainESD.7z"

          if (-not (Test-Path $mainESD)) {
            throw "ESD file $mainESD not found"
          }

          Write-Host "Splitting ESD to 7z parts (size: $splitSize)"
          7z.exe a "$7zPrefix" "$mainESD" -v$splitSize -y -mx=9 -bb0 | Out-Null
          if ($LASTEXITCODE -ne 0) {
            throw "7z split failed"
          }

          $splitFiles = Get-ChildItem "$7zPrefix.*"
          Write-Host "Split success, generated $($splitFiles.Count) files"
          Remove-Item $mainESD -Force

      - name: Publish to GitHub Release
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          $splitFiles = Get-ChildItem "$7zPrefix.*"

          if (-not $splitFiles) {
            throw "No split files to upload"
          }

          gh release delete $releaseTag -y 2>&1 | Out-Null
          gh release create $releaseTag `
            --title "$releaseTag" `
            --notes "Windows7 ESD Build $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"

          foreach ($file in $splitFiles) {
            Write-Host "Uploading $($file.Name)"
            gh release upload $releaseTag "$($file.FullName)" --clobber
          }
          Write-Host "All files uploaded to Release: $releaseTag"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Final cleanup
        run: |
          Write-Host "Final cleanup"
          Get-ChildItem -Path @("*.7z.*", "*.wim", $env:MAIN_ESD_NAME, "dism_*.txt") -ErrorAction SilentlyContinue | Remove-Item -Force
          Get-ChildItem -Path * -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match "Windows7" } | Remove-Item -Recurse -Force
          Write-Host "Cleanup completed"
