name: Windows_7_ULT&ENT_32&64

on:
  workflow_dispatch:

env:
  # 固定下载地址变量
  install_Windows7x86ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  install_Windows7x86ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  install_Windows7x86ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  install_Windows7x86ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  install_Windows7x86ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  install_Windows7x86ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  install_Windows7x64ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  install_Windows7x64ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  install_Windows7x64ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  install_Windows7x64ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  install_Windows7x64ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  install_Windows7x64ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003
  # 统一ESD文件名（无额外引号）
  MAIN_ESD_NAME: Windows_7_ULT&ENT_32&64.esd
  # 7z分卷大小
  SPLIT_VOLUME_SIZE: 1950M
  # 版本处理配置
  VERSION_CONFIG: |
    [
      {"Name":"Windows7x86ULTIMATE","ESDIndex":5,"Parts":3},
      {"Name":"Windows7x86ENTERPRISE","ESDIndex":1,"Parts":3},
      {"Name":"Windows7x64ULTIMATE","ESDIndex":4,"Parts":3},
      {"Name":"Windows7x64ENTERPRISE","ESDIndex":1,"Parts":3}
    ]

jobs:
  process_and_upload:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    
    steps:
      # ==============================================
      # 1. 检出代码
      # ==============================================
      - name: Checkout repository
        uses: actions/checkout@v4

      # ==============================================
      # 2. 增强版编码配置（核心修复：确保ANSI编码可调用）
      # ==============================================
      - name: Critical encoding setup (Robust ANSI/UTF8)
        run: |
          # 强制加载CodePagesEncodingProvider，多次尝试确保成功
          try {
            $encodingProvider = [System.Text.CodePagesEncodingProvider]::Instance
            [System.Text.Encoding]::RegisterProvider($encodingProvider)
            Write-Host "CodePagesEncodingProvider注册成功"
          } catch {
            Write-Warning "首次注册编码提供器失败：$_，重试..."
            # 重试注册
            $assembly = [System.Reflection.Assembly]::LoadWithPartialName("System.Text.Encoding.CodePages")
            $encodingProvider = [System.Text.CodePagesEncodingProvider]::Instance
            [System.Text.Encoding]::RegisterProvider($encodingProvider)
            Write-Host "重试后编码提供器注册成功"
          }
          
          # 初始化编码变量，失败则用UTF8兜底
          try {
            $global:ANSI_ENCODING = [System.Text.Encoding]::GetEncoding(936)
            $global:UTF8_ENCODING = [System.Text.Encoding]::UTF8
            Write-Host "编码配置完成："
            Write-Host "   - ANSI编码（936/GBK）：$($global:ANSI_ENCODING.EncodingName)"
            Write-Host "   - UTF8编码：$($global:UTF8_ENCODING.EncodingName)"
          } catch {
            Write-Warning "ANSI编码(936)加载失败，降级为UTF8：$_"
            $global:ANSI_ENCODING = [System.Text.Encoding]::UTF8
            $global:UTF8_ENCODING = [System.Text.Encoding]::UTF8
          }
          
          # 强制设置控制台编码
          [Console]::OutputEncoding = $global:UTF8_ENCODING
          [Console]::InputEncoding = $global:UTF8_ENCODING
          Write-Host "控制台编码已设为：$([Console]::OutputEncoding.EncodingName)"

      # ==============================================
      # 3. 安装并认证GitHub CLI
      # ==============================================
      - name: Setup GitHub CLI
        run: |
          winget install --id GitHub.cli --silent --accept-package-agreements --accept-source-agreements
          Start-Sleep -Seconds 5
          $env:GH_TOKEN | gh auth login --with-token
          gh auth status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 4. 初始化统一ESD文件
      # ==============================================
      - name: Initialize main ESD file
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          Write-Host "初始化ESD文件：$mainESD"
          
          if (Test-Path $mainESD) { 
            Remove-Item -Path $mainESD -Force 
            Write-Host "   - 已删除原有文件"
          }
          New-Item -Path $mainESD -ItemType File -Force | Out-Null
          Write-Host "ESD文件创建成功，完整路径：$((Get-Item $mainESD).FullName)"

      # ==============================================
      # 5. 循环处理所有Windows7版本（终极修复版）
      # ==============================================
      - name: Process all Windows7 versions in order
        run: |
          # 定义通用下载函数
          function Download-7zParts {
            param(
              [string]$VerName,
              [int]$PartCount
            )
            $allPartsDownloaded = $true
            Write-Host "`n开始下载$VerName分卷包（共$PartCount个）..."
            for ($i=1; $i -le $PartCount; $i++) {
              $partNum = "{0:D3}" -f $i
              $varKey = "install_${VerName}_${partNum}"
              $downloadUrl = [Environment]::GetEnvironmentVariable($varKey)
              $savePath = "$VerName.7z.$partNum"
              $retryCount = 3
              $retryInterval = 3
              $downloadOk = $false
              
              if (-not $downloadUrl) {
                Write-Error "   分卷 $i：URL为空，无法下载"
                $allPartsDownloaded = $false
                continue
              }
              
              Write-Host "   分卷 $i："
              Write-Host "      - 下载URL：$downloadUrl"
              Write-Host "      - 保存路径：$savePath"
              Write-Host "      - 重试次数：$retryCount 次，间隔 $retryInterval 秒"
              
              for ($retry=1; $retry -le $retryCount; $retry++) {
                try {
                  if (Test-Path $savePath) {
                    Remove-Item -Path $savePath -Force
                    Write-Host "      - 重试$retry：删除已有不完整文件 $savePath"
                  }
                  
                  & curl.exe -L -o "$savePath" $downloadUrl
                  Start-Sleep -Seconds 1
                  
                  if ($LASTEXITCODE -eq 0 -and (Test-Path $savePath) -and ((Get-Item $savePath).Length -gt 0)) {
                    $fileSize = (Get-Item $savePath).Length / 1MB
                    Write-Host "      - 重试$retry：下载成功，文件大小：$($fileSize.ToString("0.00")) MB"
                    $downloadOk = $true
                    break
                  } else {
                    $errMsg = "curl退出码：$LASTEXITCODE"
                    if (-not (Test-Path $savePath)) { 
                      $errMsg += "，文件不存在" 
                    } else { 
                      $errMsg += "，文件大小：$((Get-Item $savePath).Length) 字节" 
                    }
                    throw $errMsg
                  }
                } catch {
                  Write-Warning "      - 重试$retry：下载失败，原因：$_"
                  if ($retry -eq $retryCount) {
                    Write-Error "      - 分卷 $i：$retryCount 次重试均失败，无法下载"
                    $allPartsDownloaded = $false
                  } else {
                    Write-Host "      - 等待 $retryInterval 秒后重试..."
                    Start-Sleep -Seconds $retryInterval
                  }
                }
              }
              
              if (-not $downloadOk) {
                break
              }
            }
            
            if ($allPartsDownloaded) {
              Write-Host "`n   $VerName分卷下载完成，当前目录文件："
              Get-ChildItem -Path "$VerName.7z.*" -Name | Sort-Object | ForEach-Object { Write-Host "      - $_" }
            }
            
            return $allPartsDownloaded
          }

          $versions = $env:VERSION_CONFIG | ConvertFrom-Json
          $mainESD = $env:MAIN_ESD_NAME
          $mainESD_External = "`"$mainESD`""
          
          Write-Host "当前工作目录：$PWD"
          Write-Host "工作目录文件列表（初始）："
          Get-ChildItem -Path . -Name | Sort-Object | ForEach-Object { Write-Host "   - $_" }
          
          foreach ($ver in $versions) {
            $verName = $ver.Name
            $esdIndex = $ver.ESDIndex
            $partCount = $ver.Parts
            $unzipRetryCount = 1
            
            Write-Host "`n=================================================="
            Write-Host "开始处理版本：$verName (目标索引：$esdIndex)"
            Write-Host "=================================================="
            
            # 子步骤1：下载分卷
            $allPartsDownloaded = Download-7zParts -VerName $verName -PartCount $partCount
            if (-not $allPartsDownloaded) {
              throw "版本$verName 分卷下载不完整，终止处理"
            }

            # 子步骤2：解压分卷（绝对路径）
            Write-Host "`n步骤2：解压分卷包..."
            $first7z = "$verName.7z.001"
            $extractDir = "$verName"
            $first7z_AbsPath = (Resolve-Path -Path $first7z -ErrorAction Stop).Path
            $extractDir_AbsPath = Join-Path -Path (Resolve-Path -Path .).Path -ChildPath $extractDir
            $unzipOk = $false

            Write-Host "   解压入口文件绝对路径：$first7z_AbsPath"
            Write-Host "   解压目标目录绝对路径：$extractDir_AbsPath"
            Write-Host "   验证文件是否存在：$(Test-Path $first7z_AbsPath)"

            for ($unzipRetry=0; $unzipRetry -le $unzipRetryCount; $unzipRetry++) {
              if ($unzipRetry -gt 0) {
                Write-Host "`n   解压失败，开始第$unzipRetry次重试：删除损坏包并重新下载..."
                Get-ChildItem -Path "$verName.7z.*" -ErrorAction SilentlyContinue | Remove-Item -Force
                $allPartsDownloaded = Download-7zParts -VerName $verName -PartCount $partCount
                if (-not $allPartsDownloaded) {
                  throw "版本$verName 重新下载分卷失败，终止处理"
                }
                $first7z_AbsPath = (Resolve-Path -Path $first7z -ErrorAction Stop).Path
              }

              if (-not (Test-Path $first7z_AbsPath)) {
                Write-Warning "   未找到解压入口文件：$first7z_AbsPath"
                continue
              }

              Write-Host "   执行7z解压：7z.exe x `"$first7z_AbsPath`" -o`"$extractDir_AbsPath`" -y"
              & 7z.exe x "$first7z_AbsPath" -o"$extractDir_AbsPath" -y
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "   解压完成，目标目录：$extractDir_AbsPath"
                $unzipOk = $true
                break
              } else {
                Write-Error "   解压失败，7z退出码：$LASTEXITCODE"
                if ($unzipRetry -eq $unzipRetryCount) {
                  throw "版本$verName 解压失败（已重试$unzipRetryCount次）"
                }
              }
            }

            if (-not $unzipOk) {
              throw "版本$verName 解压失败，所有重试已用尽"
            }

            # 子步骤3：读取WIM映像名（终极修复：编码+DISM处理）
            Write-Host "`n步骤3：查找WIM文件并读取映像名..."
            $wimFiles = Get-ChildItem -Path $extractDir_AbsPath -Filter *.wim -Recurse -ErrorAction Stop
            if ($wimFiles.Count -eq 0) { 
              throw "未找到WIM文件（解压目录：$extractDir_AbsPath）" 
            }
            $wimFile = $wimFiles | Select-Object -First 1
            $wimPath = $wimFile.FullName
            $wimPath_External = "`"$wimPath`""
            
            Write-Host "   找到WIM文件：$wimPath"
            if ((Get-Item $wimPath).Length -eq 0) {
              throw "WIM文件为空（损坏）：$wimPath"
            }
            
            # 核心修复：DISM执行+编码处理拆分
            Write-Host "   读取WIM索引$esdIndex的映像名..."
            $dismCommand = "dism /Get-WimInfo /WimFile:$wimPath_External /Index:$esdIndex"
            Write-Host "   执行DISM命令：$dismCommand"
            
            try {
              # 第一步：执行DISM，确保输出不为空
              $dismRawOutput = & dism /Get-WimInfo /WimFile:$wimPath_External /Index:$esdIndex 2>&1
              if ($null -eq $dismRawOutput -or $dismRawOutput.Count -eq 0) {
                throw "DISM无输出，可能是WIM索引$esdIndex不存在或文件损坏"
              }
              
              # 第二步：转为字符串（避免数组/空值问题）
              $dismOutputStr = $dismRawOutput | Out-String
              if ([string]::IsNullOrEmpty($dismOutputStr)) {
                throw "DISM输出为空字符串"
              }
              
              # 第三步：编码转换（兜底处理）
              try {
                $dismOutputBytes = $global:ANSI_ENCODING.GetBytes($dismOutputStr)
                $dismOutputFinal = $global:ANSI_ENCODING.GetString($dismOutputBytes)
              } catch {
                Write-Warning "ANSI编码转换失败，使用原始输出：$_"
                $dismOutputFinal = $dismOutputStr
              }
              
              # 第四步：提取映像名
              $imageNameMatch = [regex]::Match($dismOutputFinal, 'Image Name\s*:\s*(.+)')
              if ($imageNameMatch.Success) {
                $imageName = $imageNameMatch.Groups[1].Value.Trim()
                if ([string]::IsNullOrEmpty($imageName)) {
                  throw "映像名提取为空"
                }
                Write-Host "成功读取映像名：$imageName"
              } else {
                throw "未找到映像名（Image Name）`nDISM输出：$dismOutputFinal"
              }
            } catch {
              throw "读取WIM映像名失败：$_`nDISM命令：$dismCommand`nWIM路径：$wimPath"
            }

            # 子步骤4：WIM转ESD
            Write-Host "`n步骤4：转换WIM索引$esdIndex为ESD并追加..."
            & dism /Export-Image `
              /SourceImageFile:$wimPath_External `
              /SourceIndex:$esdIndex `
              /DestinationImageFile:$mainESD_External `
              /Compress:recovery `
              /CheckIntegrity `
              /Append
            if ($LASTEXITCODE -ne 0) { 
              throw "DISM转换失败，退出码：$LASTEXITCODE" 
            }
            Write-Host "ESD追加成功，保留映像名：$imageName"

            # 子步骤5：清理临时文件
            Write-Host "`n步骤5：删除临时文件..."
            if (Test-Path $wimPath) { Remove-Item -Path $wimPath -Force }
            if (Test-Path $extractDir_AbsPath) { Remove-Item -Path $extractDir_AbsPath -Recurse -Force }
            Get-ChildItem -Path "$verName.7z.*" -ErrorAction SilentlyContinue | Remove-Item -Force
            Write-Host "临时文件删除完成"

            Write-Host "`n=================================================="
            Write-Host "版本$verName处理完成！"
            Write-Host "==================================================`n"
          }

      # ==============================================
      # 6. 7z分卷压缩ESD
      # ==============================================
      - name: Split ESD with 7z (1950M/卷)
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          $splitSize = $env:SPLIT_VOLUME_SIZE
          $7zPrefix = "$mainESD.7z"
          
          Write-Host "`n开始分卷压缩ESD文件：$mainESD"
          Write-Host "   分卷大小：$splitSize，前缀：$7zPrefix"
          
          if (-not (Test-Path $mainESD)) { throw "主ESD文件不存在：$mainESD" }
          if ((Get-Item $mainESD).Length -eq 0) { throw "主ESD文件为空" }
          
          & 7z.exe a "$7zPrefix" "$mainESD" -v$splitSize -y -mx=9
          if ($LASTEXITCODE -ne 0) { throw "7z分卷失败，退出码：$LASTEXITCODE" }
          
          Remove-Item -Path $mainESD -Force
          $splitFiles = Get-ChildItem -Path "$7zPrefix.*" | Select-Object -ExpandProperty Name
          Write-Host "分卷完成，生成文件：$($splitFiles -join ", ")"

      # ==============================================
      # 7. 删除原有Release/Tag
      # ==============================================
      - name: Delete existing Release and Tag
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $retryTimes = 10
          $retryInterval = 30

          Write-Host "`n删除原有Release：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              gh release delete $releaseTag -y
              Write-Host "Release删除成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次删除Release失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }

          Write-Host "`n删除原有Tag：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              if (git tag -l $releaseTag) { git tag -d $releaseTag }
              git push origin --delete $releaseTag
              Write-Host "Tag删除成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次删除Tag失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 8. 创建Release并上传
      # ==============================================
      - name: Create Release and upload split files
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $retryTimes = 10
          $retryInterval = 30
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          
          $splitFiles = Get-ChildItem -Path "$7zPrefix.*" -ErrorAction Stop
          if ($splitFiles.Count -eq 0) { throw "无7z分卷文件可上传" }
          
          Write-Host "`n创建新Release：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              gh release create $releaseTag `
                --title "$releaseTag" `
                --notes "Windows7 ULT&ENT 32&64 合并ESD（7z分卷1950M/卷）"
              Write-Host "Release创建成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次创建Release失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }

          Write-Host "`n上传分卷文件（共$($splitFiles.Count)个）..."
          foreach ($file in $splitFiles) {
            $filePath = $file.FullName
            Write-Host "   上传：$filePath"
            
            for ($i=1; $i -le $retryTimes; $i++) {
              try {
                gh release upload $releaseTag "$filePath" --clobber
                Write-Host "$($file.Name) 上传成功（第$i次尝试）"
                break
              } catch {
                Write-Warning "第$i次上传$($file.Name)失败：$_"
                Start-Sleep -Seconds $retryInterval
              }
            }
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 9. 最终清理
      # ==============================================
      - name: Final cleanup
        run: |
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          Write-Host "`n最终清理临时文件..."
          
          Get-ChildItem -Path "$7zPrefix.*" -ErrorAction SilentlyContinue | Remove-Item -Force
          Get-ChildItem -Path @("*.7z.*", "*.wim", $env:MAIN_ESD_NAME) -ErrorAction SilentlyContinue | Remove-Item -Force
          
          Write-Host "所有临时文件清理完成"
