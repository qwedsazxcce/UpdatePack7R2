name: Windows_7_ULT&ENT_32&64

on:
  workflow_dispatch:

env:
  # 固定下载地址变量
  install_Windows7x86ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  install_Windows7x86ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  install_Windows7x86ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  install_Windows7x86ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  install_Windows7x86ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  install_Windows7x86ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  install_Windows7x64ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  install_Windows7x64ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  install_Windows7x64ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  install_Windows7x64ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  install_Windows7x64ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  install_Windows7x64ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003
  # 统一ESD文件名（无额外引号）
  MAIN_ESD_NAME: Windows_7_ULT&ENT_32&64.esd
  # 7z分卷大小
  SPLIT_VOLUME_SIZE: 1950M
  # 版本处理配置
  VERSION_CONFIG: |
    [
      {"Name":"Windows7x86ULTIMATE","ESDIndex":5,"Parts":3},
      {"Name":"Windows7x86ENTERPRISE","ESDIndex":1,"Parts":3},
      {"Name":"Windows7x64ULTIMATE","ESDIndex":4,"Parts":3},
      {"Name":"Windows7x64ENTERPRISE","ESDIndex":1,"Parts":3}
    ]

jobs:
  process_and_upload:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    
    steps:
      # ==============================================
      # 1. 检出代码
      # ==============================================
      - name: Checkout repository
        uses: actions/checkout@v4

      # ==============================================
      # 2. 关键编码配置（ANSI读WIM + UTF8日志）
      # ==============================================
      - name: Critical encoding setup (ANSI for WIM, UTF8 for log)
        run: |
          # 1. 注册ANSI编码（936=GBK），解决GetEncoding(936)可能失败的问题
          try {
            [System.Text.Encoding]::GetEncoding(936)
          } catch {
            $encodingProvider = [System.Text.CodePagesEncodingProvider]::Instance
            [System.Text.Encoding]::RegisterProvider($encodingProvider)
          }
          
          # 2. 日志输出用UTF8（避免乱码）
          [Console]::OutputEncoding = [System.Text.Encoding]::UTF8
          [Console]::InputEncoding = [System.Text.Encoding]::UTF8
          
          # 3. 定义ANSI编码对象（读取WIM元数据用）
          $global:ANSI_ENCODING = [System.Text.Encoding]::GetEncoding(936)
          $global:UTF8_ENCODING = [System.Text.Encoding]::UTF8
          
          Write-Host "编码配置完成："
          Write-Host "   - 读取WIM元数据：ANSI(936/GBK)"
          Write-Host "   - 日志输出：UTF8"
          Write-Host "   - ANSI编码名称：$($global:ANSI_ENCODING.EncodingName)"

      # ==============================================
      # 3. 安装并认证GitHub CLI
      # ==============================================
      - name: Setup GitHub CLI
        run: |
          winget install --id GitHub.cli --silent --accept-package-agreements --accept-source-agreements
          Start-Sleep -Seconds 5
          $env:GH_TOKEN | gh auth login --with-token
          gh auth status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 4. 初始化统一ESD文件（修复路径引号）
      # ==============================================
      - name: Initialize main ESD file
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          Write-Host "初始化ESD文件：$mainESD"
          
          if (Test-Path $mainESD) { 
            Remove-Item -Path $mainESD -Force 
            Write-Host "   - 已删除原有文件"
          }
          # PowerShell内部命令直接用变量，自动处理&特殊字符
          New-Item -Path $mainESD -ItemType File -Force | Out-Null
          Write-Host "ESD文件创建成功，完整路径：$((Get-Item $mainESD).FullName)"

      # ==============================================
      # 5. 循环处理所有Windows7版本（核心修复WIM读取）
      # ==============================================
      - name: Process all Windows7 versions in order
        run: |
          $versions = $env:VERSION_CONFIG | ConvertFrom-Json
          $mainESD = $env:MAIN_ESD_NAME
          # 外部命令（DISM/7z）用双引号包裹路径
          $mainESD_External = "`"$mainESD`""
          
          foreach ($ver in $versions) {
            $verName = $ver.Name
            $esdIndex = $ver.ESDIndex
            $partCount = $ver.Parts
            
            Write-Host "`n=================================================="
            Write-Host "开始处理版本：$verName (目标索引：$esdIndex)"
            Write-Host "=================================================="
            
            # ------------------------------
            # 子步骤1：下载分卷压缩包
            # ------------------------------
            Write-Host "`n步骤1：下载分卷包..."
            for ($i=1; $i -le $partCount; $i++) {
              $partNum = "{0:D3}" -f $i
              $varKey = "install_${verName}_${partNum}"
              $downloadUrl = [Environment]::GetEnvironmentVariable($varKey)
              $savePath = "$verName.7z.$partNum"
              $savePath_External = "`"$savePath`""
              
              if ($downloadUrl) {
                Write-Host "   下载分卷 $i：$downloadUrl -> $savePath"
                # curl是外部命令，用带引号的路径
                & curl.exe -L -o $savePath_External $downloadUrl
                if ($LASTEXITCODE -ne 0) { throw "分卷 $i 下载失败，退出码：$LASTEXITCODE" }
              } else {
                Write-Warning "   分卷 $i 无下载地址，跳过"
              }
            }

            # ------------------------------
            # 子步骤2：解压分卷压缩包
            # ------------------------------
            Write-Host "`n步骤2：解压分卷包..."
            $first7z = "$verName.7z.001"
            $first7z_External = "`"$first7z`""
            $extractDir = "$verName"
            $extractDir_External = "`"$extractDir`""
            
            if (Test-Path $first7z) {
              # 7z是外部命令，用带引号的路径
              & 7z.exe x $first7z_External -o$extractDir_External -y
              if ($LASTEXITCODE -ne 0) { throw "解压失败，退出码：$LASTEXITCODE" }
              Write-Host "   解压完成，目标目录：$extractDir"
            } else {
              throw "未找到解压入口文件：$first7z"
            }

            # ------------------------------
            # 子步骤3：查找WIM文件 + 读取ANSI编码的映像名（核心修复）
            # ------------------------------
            Write-Host "`n步骤3：查找WIM文件并读取映像名（ANSI编码）..."
            $wimFiles = Get-ChildItem -Path $extractDir -Filter *.wim -Recurse -ErrorAction Stop
            if ($wimFiles.Count -eq 0) { throw "未找到WIM文件" }
            $wimFile = $wimFiles | Select-Object -First 1
            $wimPath = $wimFile.FullName
            $wimPath_External = "`"$wimPath`""
            
            Write-Host "   找到WIM文件：$wimPath"
            
            # 关键：用DISM读取WIM元数据，并用ANSI编码解析输出（避免映像名丢失）
            Write-Host "   读取WIM索引$esdIndex的映像名（ANSI解码）..."
            $dismOutput = & dism /Get-WimInfo /WimFile:$wimPath_External /Index:$esdIndex 2>&1
            # 将DISM输出（ANSI字节）转换为字符串，避免UTF8读取乱码
            $dismOutputBytes = $global:ANSI_ENCODING.GetBytes($dismOutput -join "`n")
            $dismOutputANSI = $global:ANSI_ENCODING.GetString($dismOutputBytes)
            
            # 提取映像名（Image Name）
            $imageNameLine = $dismOutputANSI | Select-String -Pattern "Image Name\s*:\s*(.*)"
            if ($imageNameLine) {
              $imageName = $imageNameLine.Matches.Groups[1].Value.Trim()
              Write-Host "成功读取映像名：$imageName"
              if ([string]::IsNullOrEmpty($imageName)) {
                throw "映像名读取为空！WIM元数据可能损坏"
              }
            } else {
              throw "无法从WIM中提取映像名，索引$esdIndex可能不存在"
            }

            # ------------------------------
            # 子步骤4：WIM转换为ESD并追加（保留映像名）
            # ------------------------------
            Write-Host "`n步骤4：转换WIM索引$esdIndex为ESD并追加..."
            & dism /Export-Image `
              /SourceImageFile:$wimPath_External `
              /SourceIndex:$esdIndex `
              /DestinationImageFile:$mainESD_External `
              /Compress:recovery `
              /CheckIntegrity `
              /Append
            if ($LASTEXITCODE -ne 0) { 
              throw "DISM转换失败，退出码：$LASTEXITCODE`nDISM输出：$dismOutputANSI" 
            }
            Write-Host "ESD追加成功，保留映像名：$imageName"

            # ------------------------------
            # 子步骤5：删除临时文件
            # ------------------------------
            Write-Host "`n步骤5：删除临时文件..."
            if (Test-Path $wimPath) { Remove-Item -Path $wimPath -Force }
            if (Test-Path $extractDir) { Remove-Item -Path $extractDir -Recurse -Force }
            Get-ChildItem -Path "$verName.7z.*" -ErrorAction SilentlyContinue | Remove-Item -Force
            Write-Host "临时文件删除完成"

            Write-Host "`n=================================================="
            Write-Host "版本$verName处理完成！"
            Write-Host "==================================================`n"
          }

      # ==============================================
      # 6. 7z分卷压缩ESD文件
      # ==============================================
      - name: Split ESD with 7z (1950M/卷)
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          $splitSize = $env:SPLIT_VOLUME_SIZE
          $7zPrefix = "$mainESD.7z"
          $7zPrefix_External = "`"$7zPrefix`""
          $mainESD_External = "`"$mainESD`""
          
          Write-Host "`n开始分卷压缩ESD文件：$mainESD"
          Write-Host "   分卷大小：$splitSize，前缀：$7zPrefix"
          
          if (-not (Test-Path $mainESD)) { throw "主ESD文件不存在：$mainESD" }
          if ((Get-Item $mainESD).Length -eq 0) { throw "主ESD文件为空" }
          
          # 7z分卷压缩（外部命令用带引号路径）
          & 7z.exe a $7zPrefix_External $mainESD_External -v$splitSize -y -mx=9
          if ($LASTEXITCODE -ne 0) { throw "7z分卷失败，退出码：$LASTEXITCODE" }
          
          # 删除原始ESD，保留分卷
          Remove-Item -Path $mainESD -Force
          $splitFiles = Get-ChildItem -Path "$7zPrefix.*" | Select-Object -ExpandProperty Name
          Write-Host "分卷完成，生成文件：$($splitFiles -join ", ")"

      # ==============================================
      # 7. 删除原有Release和Tag（带重试）
      # ==============================================
      - name: Delete existing Release and Tag
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $retryTimes = 10
          $retryInterval = 30

          Write-Host "`n删除原有Release：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              gh release delete $releaseTag -y
              Write-Host "Release删除成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次删除Release失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }

          Write-Host "`n删除原有Tag：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              if (git tag -l $releaseTag) { git tag -d $releaseTag }
              git push origin --delete $releaseTag
              Write-Host "Tag删除成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次删除Tag失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 8. 创建Release并上传分卷（带重试）
      # ==============================================
      - name: Create Release and upload split files
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $retryTimes = 10
          $retryInterval = 30
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          
          # 获取所有分卷文件
          $splitFiles = Get-ChildItem -Path "$7zPrefix.*" -ErrorAction Stop
          if ($splitFiles.Count -eq 0) { throw "无7z分卷文件可上传" }
          
          Write-Host "`n创建新Release：$releaseTag"
          for ($i=1; $i -le $retryTimes; $i++) {
            try {
              gh release create $releaseTag `
                --title "$releaseTag" `
                --notes "Windows7 ULT&ENT 32&64 合并ESD（7z分卷1950M/卷）`n包含映像名：$imageName"
              Write-Host "Release创建成功（第$i次尝试）"
              break
            } catch {
              Write-Warning "第$i次创建Release失败：$_"
              Start-Sleep -Seconds $retryInterval
            }
          }

          Write-Host "`n上传分卷文件（共$($splitFiles.Count)个）..."
          foreach ($file in $splitFiles) {
            $filePath = $file.FullName
            $filePath_External = "`"$filePath`""
            Write-Host "   上传：$filePath"
            
            for ($i=1; $i -le $retryTimes; $i++) {
              try {
                gh release upload $releaseTag $filePath_External --clobber
                Write-Host "$($file.Name) 上传成功（第$i次尝试）"
                break
              } catch {
                Write-Warning "第$i次上传$($file.Name)失败：$_"
                Start-Sleep -Seconds $retryInterval
              }
            }
          }
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ==============================================
      # 9. 最终清理
      # ==============================================
      - name: Final cleanup
        run: |
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          Write-Host "`n最终清理临时文件..."
          
          # 删除分卷文件
          Get-ChildItem -Path "$7zPrefix.*" -ErrorAction SilentlyContinue | Remove-Item -Force
          # 兜底删除残留文件
          Get-ChildItem -Path @("*.7z.*", "*.wim", $env:MAIN_ESD_NAME) -ErrorAction SilentlyContinue | Remove-Item -Force
          
          Write-Host "所有临时文件清理完成"
