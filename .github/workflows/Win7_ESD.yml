name: Windows_7_ULT&ENT_32&64
on: [workflow_dispatch]

env:
  # 下载地址
  install_Windows7x86ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.001
  install_Windows7x86ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.002
  install_Windows7x86ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ULTIMATE-26.1.15/install_Windows7x86ULTIMATE-26.1.15.7z.003
  install_Windows7x86ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.001
  install_Windows7x86ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x86ENTERPRISE-26.1.15/install_Windows7x86ENTERPRISE-26.1.15.7z.002
  install_Windows7x86ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/Misc/test.txt
  install_Windows7x64ULTIMATE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.001
  install_Windows7x64ULTIMATE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.002
  install_Windows7x64ULTIMATE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ULTIMATE-26.1.15/install_Windows7x64ULTIMATE-26.1.15.7z.003
  install_Windows7x64ENTERPRISE_001: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.001
  install_Windows7x64ENTERPRISE_002: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.002
  install_Windows7x64ENTERPRISE_003: https://github.com/qwedsazxcce/UpdatePack7R2/releases/download/install_Windows7x64ENTERPRISE-26.1.15/install_Windows7x64ENTERPRISE-26.1.15.7z.003
  # 全局配置
  MAIN_ESD_NAME: Windows_7_ULT&ENT_32&64.esd
  SPLIT_VOLUME_SIZE: 1950M
  VERSION_CONFIG: |
    [
      {"Name":"Windows7x86ULTIMATE","ESDIndex":5,"Parts":3},
      {"Name":"Windows7x86ENTERPRISE","ESDIndex":1,"Parts":3},
      {"Name":"Windows7x64ULTIMATE","ESDIndex":4,"Parts":3},
      {"Name":"Windows7x64ENTERPRISE","ESDIndex":1,"Parts":3}
    ]

jobs:
  process_and_upload:
    runs-on: windows-latest
    defaults:
      run:
        shell: pwsh
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set system encoding to GBK
        run: |
          chcp 936 | Out-Null
          Write-Host "System encoding set to GBK (936)"

      - name: Initialize ESD file
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          if (Test-Path $mainESD) { Remove-Item $mainESD -Force }
          New-Item -Path $mainESD -ItemType File -Force | Out-Null
          Write-Host "ESD file initialized: $mainESD"

      - name: Core workflow
        run: |
          # 函数1：下载分卷
          function Download-7zParts {
            param([string]$VerName, [int]$PartCount)
            $success = $true
            for ($i=1; $i -le $PartCount; $i++) {
              $partNum = "{0:D3}" -f $i
              $url = [Environment]::GetEnvironmentVariable("install_${VerName}_${partNum}")
              $savePath = "$VerName.7z.$partNum"
              
              if (-not $url) {
                Write-Error "URL is empty for $VerName part $i"
                $success = $false
                continue
              }

              $retry = 0
              do {
                try {
                  if (Test-Path $savePath) { Remove-Item $savePath -Force }
                  curl.exe -L -o $savePath $url --connect-timeout 30 --max-time 300
                  
                  if ($LASTEXITCODE -ne 0 -or (Get-Item $savePath).Length -lt 1KB) {
                    throw "Download failed or file size too small"
                  }
                  
                  Write-Host "$VerName part $i downloaded successfully: $([math]::Round((Get-Item $savePath).Length/1MB,2)) MB"
                  break
                }
                catch {
                  $retry++
                  Write-Warning "Retry $retry/3 for $VerName part $i : $_"
                  if ($retry -eq 3) {
                    $success = $false
                    break
                  }
                  Start-Sleep -Seconds 5
                }
              } while ($retry -lt 3)

              if (-not $success) { break }
            }
            return $success
          }

          # 函数2：读取WIM信息（核心修复：空值判空+默认值）
          function Get-WimIndexInfo {
            param([string]$WimPath, [int]$TargetIndex)
            $tempOut = "dism_out.txt"
            $tempErr = "dism_err.txt"

            if (Test-Path $tempOut) { Remove-Item $tempOut -Force }
            if (Test-Path $tempErr) { Remove-Item $tempErr -Force }

            try {
              # 执行DISM并捕获输出
              cmd /c "chcp 936 && dism.exe /Get-WimInfo /WimFile:`"$WimPath`" /Index:$TargetIndex > $tempOut 2> $tempErr"
              $dismExitCode = $LASTEXITCODE

              # 读取输出（确保文件存在）
              $dismOut = if (Test-Path $tempOut) { Get-Content $tempOut -Encoding Default -Raw } else { "" }
              $dismErr = if (Test-Path $tempErr) { Get-Content $tempErr -Encoding Default -Raw } else { "" }

              # 校验DISM执行结果
              if ($dismExitCode -ne 0) {
                throw "DISM exited with code $dismExitCode : $dismErr"
              }
              if ([string]::IsNullOrWhiteSpace($dismOut)) {
                throw "DISM output is empty, cannot parse WIM info"
              }

              # 核心修复：正则匹配后先判空，再取值（避免空数组索引）
              # 解析索引
              $indexMatches = [regex]::Matches($dismOut, '(?mi)^Index\s*:\s*(\d+)')
              $validIndexes = @()
              if ($indexMatches.Success) {
                foreach ($match in $indexMatches) {
                  if ($match.Groups.Count -ge 2 -and $match.Groups[1].Value -match '^\d+$') {
                    $validIndexes += [int]$match.Groups[1].Value
                  }
                }
              }
              $validIndexes = $validIndexes | Select-Object -Unique | Sort-Object

              # 解析名称（判空+默认值）
              $nameMatch = [regex]::Match($dismOut, '(?mi)^Name\s*:\s*(.+)')
              $imageName = "Unknown Image Name"
              if ($nameMatch.Success -and $nameMatch.Groups.Count -ge 2) {
                $imageName = $nameMatch.Groups[1].Value.Trim()
              }

              # 解析描述（判空+默认值）
              $descMatch = [regex]::Match($dismOut, '(?mi)^Description\s*:\s*(.+)')
              $imageDesc = "Unknown Image Description"
              if ($descMatch.Success -and $descMatch.Groups.Count -ge 2) {
                $imageDesc = $descMatch.Groups[1].Value.Trim()
              }

              # 返回安全的结果对象
              return [PSCustomObject]@{
                ValidIndexes = $validIndexes
                ImageName    = $imageName
                ImageDesc    = $imageDesc
              }
            }
            catch {
              # 抛出详细错误但不中断整体流程
              throw "DISM info parse error : $_`nDISM Output: $dismOut`nDISM Error: $dismErr"
            }
            finally {
              # 清理临时文件
              Remove-Item $tempOut, $tempErr -Force -ErrorAction SilentlyContinue
            }
          }

          # 主逻辑
          $versions = $env:VERSION_CONFIG | ConvertFrom-Json
          $mainESDAbs = (Resolve-Path $env:MAIN_ESD_NAME).Path

          foreach ($ver in $versions) {
            $verName = $ver.Name
            $targetIdx = $ver.ESDIndex
            $partCount = $ver.Parts

            Write-Host "`n====================================="
            Write-Host "Processing: $verName (Index: $targetIdx)"
            Write-Host "====================================="

            # 1. 下载
            Write-Host "1. Downloading $verName parts"
            if (-not (Download-7zParts -VerName $verName -PartCount $partCount)) {
              Write-Error "Download failed for $verName, skip to next version"
              continue
            }

            # 2. 解压
            Write-Host "2. Extracting $verName"
            $first7z = "$verName.7z.001"
            $extractDir = "$verName"
            7z.exe x "$first7z" -o"$extractDir" -y -bb0 | Out-Null
            if ($LASTEXITCODE -ne 0 -or -not (Test-Path $extractDir)) {
              Write-Error "Extract failed for $verName, skip to next version"
              continue
            }

            # 3. 找WIM
            Write-Host "3. Finding WIM file"
            $wimFile = Get-ChildItem -Path $extractDir -Filter *.wim -Recurse | Select-Object -First 1
            if (-not $wimFile) {
              Write-Error "No WIM file found for $verName, skip to next version"
              continue
            }
            $wimPath = $wimFile.FullName
            Write-Host "Found WIM: $wimPath ($([math]::Round($wimFile.Length/1GB,2)) GB)"

            # 4. 读WIM信息（容错处理）
            Write-Host "4. Reading WIM info for index $targetIdx"
            try {
              $wimInfo = Get-WimIndexInfo -WimPath $wimPath -TargetIndex $targetIdx
              
              # 校验索引（即使索引为空也给出提示，不中断）
              if ($wimInfo.ValidIndexes.Count -eq 0) {
                Write-Warning "No valid indexes found in WIM, continue with target index $targetIdx"
              } elseif (-not $wimInfo.ValidIndexes.Contains($targetIdx)) {
                Write-Warning "Target index $targetIdx not found in WIM (valid indexes: $($wimInfo.ValidIndexes -join ', ')), continue anyway"
              }
              
              Write-Host "Image Name: $($wimInfo.ImageName)"
              Write-Host "Image Description: $($wimInfo.ImageDesc)"
            }
            catch {
              Write-Warning "Read WIM info failed : $_"
              Write-Host "Continue processing $verName without WIM info validation"
            }

            # 5. 转ESD（核心功能，即使WIM信息读取失败也执行）
            Write-Host "5. Converting WIM to ESD"
            dism.exe /Export-Image `
              /SourceImageFile:"$wimPath" `
              /SourceIndex:$targetIdx `
              /DestinationImageFile:"$mainESDAbs" `
              /Compress:recovery `
              /CheckIntegrity `
              /Append | Out-Null
            
            if ($LASTEXITCODE -eq 0) {
              $esdSize = [math]::Round((Get-Item $mainESDAbs).Length/1GB,2)
              Write-Host "ESD conversion success, size: $esdSize GB"
            }
            else {
              Write-Error "ESD conversion failed for $verName, skip to next version"
              # 清理当前版本临时文件
              Remove-Item $extractDir -Recurse -Force -ErrorAction SilentlyContinue
              Remove-Item "$verName.7z.*" -Force -ErrorAction SilentlyContinue
              continue
            }

            # 6. 清理
            Write-Host "6. Cleaning up temp files"
            Remove-Item $extractDir -Recurse -Force -ErrorAction SilentlyContinue
            Remove-Item "$verName.7z.*" -Force -ErrorAction SilentlyContinue
          }

      - name: Split ESD to 7z
        run: |
          $mainESD = $env:MAIN_ESD_NAME
          $splitSize = $env:SPLIT_VOLUME_SIZE
          $7zPrefix = "$mainESD.7z"

          if (-not (Test-Path $mainESD)) {
            Write-Warning "ESD file $mainESD not found, skip splitting"
            exit 0
          }

          Write-Host "Splitting ESD to 7z parts (size: $splitSize)"
          7z.exe a "$7zPrefix" "$mainESD" -v$splitSize -y -mx=9 -bb0 | Out-Null
          
          if ($LASTEXITCODE -ne 0) {
            throw "7z split failed with exit code $LASTEXITCODE"
          }

          $splitFiles = Get-ChildItem "$7zPrefix.*"
          Write-Host "Split success, generated $($splitFiles.Count) files"
          Remove-Item $mainESD -Force

      - name: Publish to GitHub Release
        run: |
          $releaseTag = "Windows_7_ULT&ENT_32&64"
          $7zPrefix = "$($env:MAIN_ESD_NAME).7z"
          $splitFiles = Get-ChildItem "$7zPrefix.*"

          if (-not $splitFiles -or $splitFiles.Count -eq 0) {
            Write-Warning "No split files to upload, skip release"
            exit 0
          }

          # 简化发布逻辑，容错处理
          gh release delete $releaseTag -y 2>&1 | Out-Null
          $releaseCreate = gh release create $releaseTag `
            --title "$releaseTag" `
            --notes "Windows7 ESD Build $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')"
          
          if (-not $releaseCreate) {
            Write-Warning "Failed to create release, skip upload"
            exit 0
          }

          foreach ($file in $splitFiles) {
            Write-Host "Uploading $($file.Name)"
            gh release upload $releaseTag "$($file.FullName)" --clobber 2>&1 | Out-Null
          }
          Write-Host "All files uploaded to Release: $releaseTag"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Final cleanup
        run: |
          Write-Host "Final cleanup"
          Get-ChildItem -Path @("*.7z.*", "*.wim", $env:MAIN_ESD_NAME, "dism_*.txt") -ErrorAction SilentlyContinue | Remove-Item -Force
          Get-ChildItem -Path * -Directory -ErrorAction SilentlyContinue | Where-Object { $_.Name -match "Windows7" } | Remove-Item -Recurse -Force
          Write-Host "Cleanup completed"
